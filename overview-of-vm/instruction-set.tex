\subsection{Instruction Set} \label{subsec:instruction-set}

Whilst designing a ZKVM we also considered the complexity of verification, in addition to the execution efficiency of the VM itself, which differs from the traditional design principles of the instruction set. Purely pursuing efficient execution of instructions is not our goal, we have other fundamental design objectives, such as achieving short and concise verification complexity (occupying fewer trace cell units).

For example: when you have two instruction sets $A$ and $B$, there is an ``is\_zero" instruction in instruction set $A$, which is used to judge ``if x = 0, res = 1, otherwise, res = 0”, and except for this instruction, instruction set $B$ is identical to instruction set $A$. We denote the number of track units occupied by a CPU based on instruction set $A$ to execute an instruction by $a$ (for simplicity, assuming that all instructions consume the same number of units), and the number of track units required to execute one step based on instruction set $B$ by $b$ (where $a>b$ due to the added complexity of additional instructions). On the other hand, if a deterministic program is written based on instruction set $A$, it will execute $k_A$; and if it's written based on instruction set $B$, it will execute $k_B$ ($k_B>k_A$, it is possible to utilize more instructions to execute ``is\_zero”). If $a \cdot k_A < b \cdot k_B$, instruction set $A$ is more suitable for this program; conversely, instruction set $B$ is more suitable. When deciding whether to intervene in an instruction, we should consider the relationship between the additional cost of each step ($a/b$) and the additional steps added ($k_A/k_B$).

Based on the principles above, the instruction sets we designed are as shown in Table \ref{table:instruction-set}, \verb|flag| is a special register that stores the flag of \verb|overflow| or \verb|borrow|.


\begin{table}[!ht]
    \resizebox{\textwidth}{!}{%
    \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    \textit{Type} & \textit{Encoding} & \textit{Instruction} & \textit{Operands} & \textit{Description} & \textit{flag} \\ \hline
    \multirow{2}{*}{Logic} & 00001 & ADD & ri rj A & Compute [ri] + [A] and store the result in ri & overflow \\ \cline{2-6} 
     & 00010 & MUL & ri rj A & Compute [rj] * [A] and store the least significant bits of the result in ri & overflow \\ \hline
    Cmp & 00011 & EQ & ri A & Equality comparison & r[i] = [A] \\ \hline
    Move & 00100 & MOV & ri A & Store [A] in ri &  \\ \hline
    \multirow{4}{*}{Flow} & 00101 & JMP & A & Set pc to [A] &  \\ \cline{2-6} 
     & 00110 & CJMP & A & If flag = 1, set pc to [A], else increment pc as usual &  \\ \cline{2-6} 
     & 00111 & CALL & A & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}The Call instruction consists of the following steps\\ 1. store the fp register to the latest unused memory address.\\ 2. store return pc to the next memory address.\\ 3. update the value in the fp register to the latest memory address\\ 4. jump to the address in register A\end{tabular}} &  \\ \cline{2-6} 
     & 01000 & RET &  & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}The Ret instruction consists of the following two steps\\ 1. use the memory address stored in the fp register to find the returned pc and jump to the location of the returned pc.\\ 2. update the fp register to the fp before the call\end{tabular}} &  \\ \hline
    \multirow{2}{*}{RAM} & 01001 & MLOAD & ri A & Load the Word in memory begin with start index is [A] and store the Word into ri &  \\ \cline{2-6} 
     & 01010 & MSTORE & A ri & Store [ri] at the start of memory where the start index is [A] &  \\ \hline
    \end{tabular}%
    }
    \caption{Instruction set}
    \label{table:instruction-set}   
    \end{table}

\emph{Note:} The operands of the instruction can be either registers or immediate numbers.
