\subsection{Our Work}

Designing and implementing a fully functional ZKEVM is a very daunting and challenging task. We have thoroughly studied and followed the progress of other teams in this space, and mastered how to design an efficient ZK-friendly EVM.

OlaVM is designed to have strong EVM compatibility without compromising its ZK-friendliness. To maintain its ZK-friendliness we've defined a simple instruction set, which makes the underlying state transition constraints very concise. In addition to this, OlaVM is a register-based VM, which significantly reduces the execution trace (avoiding intensive PUSH and POP operations compared to a stack-based VM). The Word of OlaVM is an element defined in a finite field, that's how we are able to obtain a simplified set of instructions. Finally, OlaVM supports some neat tricks to prevent the VM itself from performing complex calculations, reducing the execution trace and thereby improving overall ZK efficiency. We have defined integer calculation logic of uint256 to achieve solid EVM compatibility. In order to reduce the execution trace of integer calculation, we use BLS12-381 curve, which is defined on a 381-bit characteristic finite field.

In terms of design, based on the technical characteristics described above, OlaVM generates smaller execution traces and more concise state transition constraints, which enables us to achieve better ZK efficiency.

In addition to that we utilize other technical means such as reducing the number of selector polynomials by Combined Selector technology, as well as reducing the constraint scale using Lookup Argument technology, in order to improve ZK efficiency. For detailed principle, please refer to Section \ref{sec:key-technologies}. To further improve ZK efficiency, we have got a ZK hardware acceleration design framework. In order to ensure scalability of the design, we only accelerate the core module in ZK algorithm -- MSM (Multi-Scalar Multiplication), so that our design still applies to other ZK algorithms.

OlaVM uses a ZK algorithm without FFT in our design (for detailed principle, please refer to Section \ref{sec:zk-without-fft}), not simply a classic ZK algorithm, such as Halo2 \cite{website:halo2}, Plonk \cite{cryptoeprint:2019/953}, Plonky2 \cite{website:plonky2} and Groth16 \cite{Groth16}. Reasoning behind this is, with ZK algorithms, although FFT/IFFT and MSM calculations occupy most of the execution time of the entire algorithm, due to the computational complexity of FFT being $O(N\log N)$ and the MSM being $O(N/\log N)$ (Do note that at this complexity, a lot of hardware buffers are required), as the circuit size increases, FFT/IFFT will consume more computing resources than MSM (MSM has more multipliers than FFT/IFFT for a single multiplication even if for the bit width).

It should be noted that compared to the traditional ZK algorithms of R1CS system, such as BCTV14 \cite{ben2014succinct}, Halo \cite{cryptoeprint:2019/1021} and Fractal \cite{Fractal}, current ZK algorithms without FFT based on R1CS system, such as Nova \cite{cryptoeprint:2021/370} and Spartan \cite{Spartan}, has more efficient performance in proving, verifying, recursive performance and so on.

We believe that a ZK algorithm without FFT based on Plonkish constraint system will have better performance, although it is not considering optimal now, we will continue studying and researching this, as well as showcasing the hardware acceleration scheme of its main computing module, MSM, in advance.
